'use strict';
const path = require('path');
const fs = require('fs');
const {promisify} = require('util');
const pLocate = require('p-locate');

const fsStat = promisify(fs.stat);
const fsLStat = promisify(fs.lstat);

const typeMappings = {
	directory: 'isDirectory',
	file: 'isFile'
};

function checkType({type}) {
	if (type in typeMappings) {
		return;
	}

	throw new Error(`Invalid type specified: ${type}`);
}

const matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();

module.exports.sync = (paths, options) => {
	options = {
		cwd: process.cwd(),
		allowSymlinks: true,
		type: 'file',
		...options
	};
	checkType(options);
  // fs.statSync 获取文件信息状态
  // https://nodejs.cn/api/fs.html#fsstatsyncpath-options
	const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;

	for (const path_ of paths) {
		try {
			const stat = statFn(path.resolve(options.cwd, path_));

      // 如果存在则返回
			if (matchType(options.type, stat)) {
				return path_;
			}
		} catch (_) {
		}
	}
};


// fs.statSync
function statSync(path, options = { bigint: false, throwIfNoEntry: true }) {
  path = getValidatedPath(path);
  const ctx = { path };
  const stats = binding.stat(pathModule.toNamespacedPath(path),
                             options.bigint, undefined, ctx);
  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {
    return undefined;
  }
  handleErrorFromBinding(ctx);
  return getStatsFromBinding(stats);
}
